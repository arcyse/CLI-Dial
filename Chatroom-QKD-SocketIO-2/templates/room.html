{% extends "base.html" %}
{% block content %}
<div class="message-box">
    <h2>Chat Room: {{ code }}</h2>
    <div class="messages" id="messages"></div> <!-- Messages are inserted into div using SocketIO in JS -->
    <div class="inputs">
        <input type="text" rows="3" placeholder="Message" name="message" id="message"/>
        <button type="button" name="send" id="send-btn" onClick="sendMessage()"> <!-- When button clicked, calls a JS funtion to sendMessage() -->
            Send
        </button>
    </div>
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js" integrity="sha512-E8QSvWZ0eCLGk4km3hxSsNmGWbLtSCSUcewDQPQWZF6pEU8GlT8a5fF32wOl1i8ftdMhssTrF/OhyGWwonTcXA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- Add JS Script -->
<script type="text/javascript">
    // Connect to socket of hosting server:
    // Emits a connection event to backend server:
    //<!--! NOTE: WE MUST DO IO.CONNECT(https://your-server-domain-or-ip:5000) TO CONNECT TO SERVER:
    var socketio = io(); //We can call this io() since we have the CDN library of flask-socketio in the base.html file
    
    const messages = document.getElementById("messages")

    var key = 0;

    const createMessage = (name, msg) => {
        const content = `
        <div class="text">
            <span>
                <strong>${name}</strong>: ${msg}
            </span>
            <span class="muted"> 
                ${new Date().toLocaleString()} <!-- NOTE: Stores receiving time, not actual sending time -->
            </span>
        </div>
        `
        messages.innerHTML += content;
    };

    //Listen for a "message" event (when send() is called from server end):
    socketio.on("message", (data) => {
        createMessage(data.name, data.message);
    });

    // Convert binary string key to ASCII characters
    const binaryToAscii = (binaryKey) => {
        let asciiKey = '';
        for (let i = 0; i < binaryKey.length; i += 8) {
            asciiKey += String.fromCharCode(parseInt(binaryKey.substr(i, 8), 2));
        }
        return asciiKey;
    };

    // XOR encryption using ASCII key (keeps binary output)
    const xorEncrypt = (message, key) => {
        let result = '';
        for (let i = 0; i < message.length; i++) {
            result += String.fromCharCode(message.charCodeAt(i) ^ key.charCodeAt(i % key.length));
        }
        return btoa(result);  // Base64 encode the result to send it safely
    };

    const sendMessage = () => {
        const message = document.getElementById("message").value;
        if (message === "") return;

        const asciiKey = binaryToAscii(key);  // Convert binary key to ASCII
        const encrypted = xorEncrypt(message, asciiKey);  // Encrypt the message
        
        const data = {
            name: sessionStorage.getItem("name"),
            message: encrypted  // Send Base64 encoded encrypted message
        };

        socketio.emit("message", data);  // Send data to server
        document.getElementById("message").value = "";  // Clear input after sending
    };

    //<!--* Receive secret from server through QKD:
    socketio.on("key", (data) => {
        key = data;
    });
</script>

{% for msg in messages %}
    <script type="text/javascript">
        createMessage("{{ msg.name }}", "{{ msg.message }}")
    </script>
{% endfor %}
{% endblock %}